# Pushing Rust Outside of Its Comfort Zone

The thing I miss most about university, by some margin, is my programming language theory classes. Within the confines of seemingly restrictive languages, some neat, weird, and wonderfully wacky solutions can emerge. Creativity born of constraint feels like a universal phenomenon, but this was recently brought into sharp focus when I came across a compile-time Sudoku checker written solely using [Rustâ€™s type system](https://www.reddit.com/r/rust/comments/1kvpdxz/sudoku_checker_in_rust_type_system/). Naturally, the comments pointed me towards something even more unhinged, an implementation of Doom written entirely with [TypeScript types](https://www.reddit.com/r/programming/comments/1iyqeu7/typescript_types_can_run_doom/).

Despite having written my bachelorâ€™s thesis on Rust and worked with it professionally, I am still regularly impressed and fascinated by the languageâ€™s design. Its affine type system and the concept of ownership force you to solve problems in ways that go against the grain of garbage-collected programming languages. Its roots in functional programming, such as ad-hoc polymorphism, algebraic data types, and first-class functions, provide an expressive foundation. That is all before we even get to declarative and procedural macros, a system so powerful you can write your own DSLs or automate boilerplate with surgical precision.

Yes, Rust offers impressive guarantees over memory safety and "fearless concurrency". But development with it is not without trade-offs. Criticism about the maturity of its ecosystem â€” *"Rust is not ready for front-end", "There is no GUI story"*, and so on â€” often rings true. But I see those not as limitations, but as challenges, the sort I would have relished as a student and miss now.

I am by no means a front-end artist (so do not judge), but it turns out you can now write some pretty fast WebAssembly applications. The demo I have been working on takes UDP packets from the F1 series of video games, parses them, maps them over a WebSocket, and updates the DOM more than 60 times per second. Throw in a bit of matrix maths to map car coordinates onto a 2D track map, and you have a web-based live telemetry dashboard rendered entirely in the browser. It is all vanilla HTML and CSS on the front-end. Everything else is written in Rust. I built it after running into persistent latency issues with JavaScript and React-based solutions.

Because Rust is a systems language, I have also been able to reuse some of the underlying logic in embedded targets, for example, driving custom rev lights or speedometers on racing wheels.

> ðŸ’¡ P.S. The model library used for parsing game data is [open-source](https://github.com/11bthornton/f1-game-library-models) and also available on [crates.io](https://crates.io/crates/f1-game-library-models).
